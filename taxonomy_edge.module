<?php
/**
 * @file
 *
 * Selecting all children of a given taxonomy term can be a pain.
 * This module makes it easier to do this, by maintaining a complete list of
 * edges for each term using the adjecency matrix graph theory.
 *
 * Currently only MySQL is supported.
 *
 * Example of getting all children from tid:14
 *
 * SELECT tid FROM {term_edge} WHERE parent = 14
 *
 * NOTE: Multiple parents are somewhat supported.
 *
 * @todo Convert to ANSI SQL (if possible) for compatibility with other databases than MySQL
 * @todo Use batch API for rebuild edges manually.
 * @todo Integrate with Views.
 *
 * @see README.txt
 */

/**
 * Fail safe for avoiding infite loops when rebuilding edges.
 */
define('TAXONOMY_EDGE_MAX_DEPTH', 100);




// ---------- HOOKS ----------

/**
 * Implements hook_help().
 */
function taxonomy_edge_help($section) {
  switch ($section) {
    case 'admin/help#taxonomy_edge':
      // Return a line-break version of the module README.txt
      return filter_filter('process', 1, NULL, file_get_contents( dirname(__FILE__) . "/README.txt") );
  }
}

/**
 * Implementation of hook_perm().
 */
function taxonomy_edge_perm() {
  return array('administer taxonomy edge');
}

/**
 * Implementation of hook_menu().
 */
function taxonomy_edge_menu() {
  $items = array();

  // settings page
  $items['admin/content/taxonomy/edge'] = array(
    'title'            => 'Edge',
    'description'      => 'Administer taxonomy edges',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('taxonomy_edge_settings_form'),
    'access arguments' => array('administer taxonomy edge'),
    'type'             => MENU_LOCAL_TASK,
    'file'             => 'taxonomy_edge.pages.inc'
  );

  return $items;
}

/**
 * Implementation of hook_taxonomy().
 *
 * Maintain edges upon taxonomy manipulation
 */
function taxonomy_edge_taxonomy($op, $type, $array = NULL) {
  $array = (array)$array;
  switch ($type) {
    case 'term':
      switch ($op) {
        case 'insert':
          _taxonomy_edge_insert($array['tid'], $array['parent']);
          break;
        case 'update':
          _taxonomy_edge_update($array['tid'], $array['parent']);
          break;
        case 'delete':
          _taxonomy_edge_delete($array['tid']);
          break;
      }
  }
}

/**
 * Implementation of hook_cronapi().
 * Regularly rebuild the edge list
 */
function taxonomy_edge_cronapi($op, $job = NULL) {
  switch ($op) {
    case 'list':
      return array('taxonomy_edge_rebuild_cron' => 'Rebuild taxonomy edges');
    case 'rule':
      return '0 2 * * *';
  }
}




// ---------- PRIVATE HELPER FUNCTIONS ----------

/**
 * Rebuild edges
 */
function taxonomy_edge_rebuild_cron() {
  $rows = taxonomy_edge_rebuild();
  if (is_numeric($rows)) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Insert edges for a term.
 *
 * @param $tid
 *   Term ID.
 * @param $parents
 *   Parent term IDs, either one integer or an array of integers.
 * @return integer/boolean
 *   Number of rows updated or FALSE if failed.
 */
function _taxonomy_edge_insert($tid, $parents) {
  if (!is_array($parents)) {
    $parents = array($parents);
  }

  watchdog('taxonomy_edge', 'Inserting taxonomy-edge for %tid [%parent]', array('%tid' => $tid, '%parent' => join(',', $parents)), WATCHDOG_DEBUG);

  if ($tid > 0) {
    if (function_exists('db_start_transaction')) {
      db_start_transaction();
    }

    @db_query("INSERT INTO {term_edge} (tid, parent, distance) VALUES(%d, %d, 0)", $tid, $tid);
    $rows += db_affected_rows();

    foreach ($parents as $parent) {
      db_query("
        INSERT INTO {term_edge} (tid, parent, distance)
        SELECT %d, e1.parent, e1.distance + 1
        FROM {term_edge} e1
        LEFT JOIN {term_edge} e2 ON e2.tid = %d AND e2.parent = e1.parent
        WHERE e1.tid = %d
        AND e2.tid IS NULL
      ", $tid, $parent);
      $rows += db_affected_rows();
    }
    if (function_exists('db_end_transaction')) {
      db_end_transaction();
    }
    return $rows;
  }
  else {
    watchdog('taxonomy_edge', 'Invalid term-id (%tid) received', array('%tid' => $tid), WATCHDOG_ERROR);
    return FALSE;
  }
}

/**
 * Move term in the edge list.
 *
 * @param $tid
 *   Term ID.
 * @param $parents
 *   Parent term IDs, either one integer or an array of integers.
 */
function _taxonomy_edge_update($tid, $parents) {
  if (!is_array($parents)) {
    $parents = array($parents);
  }

  watchdog('taxonomy_edge', 'Updating taxonomy-edge for %tid [%parent]', array('%tid' => $tid, '%parent' => join(',', $parents)), WATCHDOG_DEBUG);

  if (function_exists('db_start_transaction')) {
    db_start_transaction();
  }

  // Find invalid edges after move
  db_query("CREATE TEMPORARY TABLE {term_edge_delete} (tid INT(11), parent INT(11), PRIMARY KEY (`tid`, `parent`))");
  db_query("
    INSERT INTO {term_edge_delete} 
    SELECT DISTINCT te2.tid, te2.parent
    FROM {term_edge} te1
    INNER JOIN {term_edge} te2 ON te1.tid = te2.tid
    WHERE te1.parent = %d AND te2.distance > te1.distance
  ", $tid);

  // Delete those edges
  db_query("
    DELETE e.*
    FROM {term_edge} e
    JOIN {term_edge_delete} ed ON e.tid = ed.tid AND e.parent = ed.parent
  ");

  // Insert new and correct edges
  $placeholders = db_placeholders($parents, 'int');
  $args = $parents;
  $args[] = $tid;
  db_query("
    INSERT INTO {term_edge} (tid, parent, distance)
    SELECT te2.tid, te1.parent, te1.distance + te2.distance + 1
    FROM {term_edge} te1
    INNER JOIN {term_edge} te2 ON te1.tid IN (" . $placeholders . ") AND te2.parent = %d
    LEFT JOIN {term_edge} te3 ON te2.tid = te3.tid AND te1.parent = te3.parent
    WHERE te3.tid IS NULL
  ", $args);
  
  // Clean up
  db_query("DROP TEMPORARY TABLE {term_edge_delete}");

  if (function_exists('db_end_transaction')) {
    db_end_transaction();
  }
}

/**
 * Delete edges
 *
 * @param $tid
 *   Term ID.
 */
function _taxonomy_edge_delete($tid) {
  db_query("DELETE FROM {term_edge} WHERE tid = %d OR parent = %d", $tid, $tid);
}




// ---------- PUBLIC HELPER FUNCTIONS ----------

/**
 * Rebuild entire edge list.
 *
 * @return integer
 *   Total number of rows inserted.
 */
function taxonomy_edge_rebuild() {
  $depth = 0;
  $max_depth = variable_get('taxonomy_edge_max_depth', TAXONOMY_EDGE_MAX_DEPTH);

  set_time_limit(86400);

  watchdog('taxonomy_edge', 'Rebuilding edges', array(), WATCHDOG_DEBUG);

  if (function_exists('db_start_transaction')) {
    db_start_transaction();
    // TRUNCATE is not transaction safe on some DB's (at least MySQL).
    db_query("DELETE FROM {term_edge}");
  }
  else {
    // Use TRUNCATE if possible, much faster than DELETE FROM (if there are many rows).
    db_query("TRUNCATE {term_edge}");
  }

  db_query("
    INSERT INTO {term_edge} (tid, parent, distance) 
    SELECT h.tid, h.tid, 0 
    FROM {term_hierarchy} h
    LEFT JOIN {term_edge} e ON e.tid = h.tid AND e.parent = h.tid
    WHERE h.tid <> 0 
    AND h.tid <> h.parent
    AND e.tid IS NULL
  ");
  $total_rows = db_affected_rows();
  watchdog('taxonomy_edge', 'distance: %distance - Rows: %rows (%total_rows)', array('%distance' => 0, '%rows' => $total_rows, '%total_rows' => $total_rows), WATCHDOG_DEBUG);

  while ($max_depth-- > 0) {
    $result = db_query("
      INSERT INTO {term_edge} (tid, parent, distance)
      SELECT h.tid, e.parent, %d
      FROM {term_hierarchy} h
      INNER JOIN {term_edge} e ON e.tid = h.parent
      LEFT JOIN {term_edge} e2 ON e2.tid = h.tid AND e2.parent = e.parent
      WHERE e.distance = %d
      AND h.tid <> 0
      AND h.tid <> h.parent
      AND e2.tid IS NULL
    ", $depth + 1, $depth);

    if (!$result) {
      break;
    }
    $depth++;

    $rows = db_affected_rows();
    $total_rows += $rows;
    watchdog('taxonomy_edge', 'distance: %distance - Rows: %rows (%total_rows)', array('%distance' => $depth, '%rows' => $rows, '%total_rows' => $total_rows), WATCHDOG_DEBUG);
    if ($rows <= 0) {
      break;
    }
  }

  if (function_exists('db_end_transaction')) {
    db_end_transaction();
  }
  return $total_rows;
}

/**
 * Get parent from edge list.
 *
 * @param $tid
 *   term id to get parent from.
 * @return array
 *   array of term ids.
 */
function taxonomy_edge_get_parents($tid) {
  $parents = array();
  $result = db_query("
    SELECT e.parent AS tid, d.name
    FROM {term_edge} e JOIN {term_data} d ON e.parent = d.tid
    WHERE e.tid = %d
    AND e.distance > 0
    ORDER BY e.distance
  ", $tid);
  while ($parent = db_fetch_object($result)) {
    $parents[] = $parent;
  }
  return $parents;
}

/**
 * Get top term id.
 *
 * @param $tid
 *   Term ID to get top term ID from.
 * @return integer
 *   Top term ID.
 */
function taxonomy_edge_get_top_tid($tid) {
  return db_result(db_query("
    SELECT h.tid
    FROM {term_edge} te
    INNER JOIN {term_hierarchy} h ON te.parent = h.tid
    WHERE h.parent = 0
    AND te.tid = %d
  ", $tid));
}

/**
 * Reimplementation of taxonomy_select_nodes().
 * Uses the Taxonomy Edge table instead of cpu/mem (mostly mem) hungry taxonomy_get_tree().
 * @note This function also fixes the "broken" default order by from the taxonomy_select_nodes() function,
 *       by added "n.nid" to the ORDER BY clause. This is ensure consistent results on each query.
 *
 * @see taxonomy_select_nodes()
 */
function taxonomy_edge_taxonomy_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC, n.nid DESC') {
  // Fix broken default order by the Taxonomy Module.
  // Ordering without a unique key could result in incosistent result sets,
  // depending on which index (if any) the database decides to use for the query.
  switch ($order) {
    case 'n.sticky DESC, n.created DESC':
      $order .= ', n.nid DESC';
      break;
    case 'n.sticky ASC, n.created ASC':
      $order .= ', n.nid ASC';
      break;
  }

  // If possible, use optimize by using GROUP BY instead of DISTINCT.
  // This is what the idx_taxonomy_edge index is used for.
  $group_by = '';
  $distinct = 'DISTINCT(n.nid)';
  switch ($order) {
    case 'n.sticky DESC, n.created DESC, n.nid DESC':
    case 'n.sticky ASC, n.created ASC, n.nid ASC':
      $group_by = ' GROUP BY n.sticky, n.created, n.nid';
      $distinct = 'n.nid';
      break;
    case 'n.created DESC, n.nid DESC':
    case 'n.created ASC, n.nid ASC':
      $group_by = ' GROUP BY n.created, n.nid';
      $distinct = 'n.nid';
      break;
  }

  if (count($tids) > 0) {
    if ($operator == 'or') {
      $args = $tids;
      $placeholders = db_placeholders($args, 'int');
      if ($depth === 'all') {
        $sql = 'SELECT ' . $distinct . ', n.sticky, n.title, n.created FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid JOIN {term_edge} te ON tn.tid = te.tid WHERE te.parent IN(' . $placeholders . ') AND n.status = 1 ' . $group_by . ' ORDER BY ' . $order;
        $sql_count = 'SELECT COUNT(DISTINCT n.nid) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid JOIN {term_edge} te ON tn.tid = te.tid WHERE te.parent IN(' . $placeholders . ') AND n.status = 1';
      }
      else {
        $sql = 'SELECT ' . $distinct . ', n.sticky, n.title, n.created FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid JOIN {term_edge} te ON tn.tid = te.tid WHERE te.parent IN(' . $placeholders . ') AND te.distance <= %d AND n.status = 1 ' . $group_by . ' ORDER BY ' . $order;
        $sql_count = 'SELECT COUNT(DISTINCT n.nid) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid JOIN {term_edge} te ON tn.tid = te.tid WHERE te.parent IN(' . $placeholders . ') AND te.distance <= %d AND n.status = 1';
        $args[] = $depth;
      }
    }
    else {
      $join = '';
      $args = array();
      foreach ($tids as $index => $tid) {
        $join .= ' INNER JOIN {term_node} tn' . $index . ' ON n.vid = tn' . $index . '.vid';
        $join .= ' INNER JOIN {term_edge} te' . $index . ' ON tn' . $index . '.tid = te'. $index . '.tid AND te' . $index . '.parent = %d';
        $args[] = $tid;
        if ($depth !== 'all') {
          $join .= ' AND te'. $index .'.distance <= %d';
          $args[] = $depth;
        }
      }
      $sql = 'SELECT ' . $distinct . ', n.sticky, n.title, n.created FROM {node} n ' . $join . ' WHERE n.status = 1 ' . $group_by . ' ORDER BY ' . $order;
      $sql_count = 'SELECT COUNT(DISTINCT n.nid) FROM {node} n ' . $join . ' WHERE n.status = 1';
    }
    $sql = db_rewrite_sql($sql);
    if ($pager) {
      $sql_count = db_rewrite_sql($sql_count);
      $result = pager_query($sql, variable_get('default_nodes_main', 10), 0, $sql_count, $args);
    }
    else {
      $result = db_query_range($sql, $args, 0, variable_get('feed_default_items', 10));
    }
  }

  return $result;
}
