<?php
/**
 * @file
 *
 * Selecting all children of a given taxonomy term can be a pain.
 * This module makes it easier to do this, by maintaining a complete list of
 * edges for each term using the adjecency matrix graph theory.
 *
 * Example of getting all children from tid:14
 *
 * SELECT tid FROM {taxonomy_term_edge} WHERE parent = 14
 *
 * NOTE: Multiple parents are somewhat supported.
 *
 * @todo Fix concurrency issue for queue rebuild and full tree rebuild
 *
 * @see README.txt
 */

/**
 * Fail safe for avoiding infite loops when rebuilding edges.
 */
define('TAXONOMY_EDGE_MAX_DEPTH', 100);

/**
 * Default value for realtime building of tree.
 */
define('TAXONOMY_EDGE_BUILD_REALTIME', TRUE);



// ---------- HOOKS ----------

/**
 * Implements hook_help().
 */
function taxonomy_edge_help($section) {
  switch ($section) {
    case 'admin/help#taxonomy_edge':
      // Return a line-break version of the module README.txt
      return check_markup(file_get_contents( dirname(__FILE__) . "/README.txt"));
  }
}

/**
 * Implementation of hook_perm().
 */
function taxonomy_edge_permission() {
  return array(
    'administer taxonomy edge' => array(
      'title' => t('Administer Taxonomy Edge'),
      'description' => t('Perform administration tasks for Taxonomy Edge.'),
    )
  );
}

/**
 * Implementation of hook_menu().
 */
function taxonomy_edge_menu() {
  $items = array();

  // settings page
  $items['admin/structure/taxonomy/edge'] = array(
    'title'            => 'Edge',
    'description'      => 'Administer taxonomy edges',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('taxonomy_edge_settings_form'),
    'access arguments' => array('administer taxonomy edge'),
    'type'             => MENU_LOCAL_TASK,
    'file'             => 'taxonomy_edge.pages.inc'
  );

  return $items;
}

/**
 * Implementation of hook_cronapi().
 * Regularly rebuild the edge list
 */
function taxonomy_edge_cronapi($op, $job = NULL) {
  switch ($op) {
    case 'list':
      return array('taxonomy_edge_cron_rebuild' => 'Rebuild taxonomy edges');
    case 'rule':
      return '0 2 * * *';
  }
}

/**
 * Implements hook_cron_queue_info().
 */
function taxonomy_edge_cron_queue_info() {
  $queues['taxonomy_edge'] = array(
    'worker callback' => 'taxonomy_edge_process_queue_item',
    'time' => 60,
  );
  return $queues;
}

/**
 * Implements hook_cron_queue_info_alter().
 */
function taxonomy_edge_cron_queue_info_alter(&$queues) {
  // If a rebuild is in progress, don't process queue before it's finished.
  // The only I've found to do this, is to remove the queue from cron, as
  // items otherwise would be lost.
  if (!lock_may_be_available('taxonomy_edge_rebuild')) {
    unset($queues['taxonomy_edge']);
  }
}

/**
 * Implements hook_taxonomy_term_insert().
 */
function taxonomy_edge_taxonomy_term_insert($term) {
  if (taxonomy_edge_build_realtime()) {
    return _taxonomy_edge_taxonomy_term_insert($term);
  }
  else {
    _taxonomy_edge_taxonomy_term_queue($term, 'insert');
  }
}

/**
 * Implements hook_taxonomy_term_update().
 */
function taxonomy_edge_taxonomy_term_update($term) {
  if (taxonomy_edge_build_realtime()) {
    return _taxonomy_edge_taxonomy_term_update($term);
  }
  else {
    _taxonomy_edge_taxonomy_term_queue($term, 'update');
  }
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function taxonomy_edge_taxonomy_term_delete($term) {
  if (taxonomy_edge_build_realtime()) {
    return _taxonomy_edge_taxonomy_term_delete($term);
  }
  else {
    _taxonomy_edge_taxonomy_term_queue($term, 'delete');
  }
}

/**
 * Hook into the drag'n'drop interface of terms in order to update tree when
 * terms are reordered.
 *
 * @param array $form
 * @param type $form_state 
 */
function taxonomy_edge_form_taxonomy_overview_terms_alter(&$form, &$form_state) {
  $form['#submit'][] = 'taxonomy_edge_reorder_submit';
}

/**
 * Copy/paste from core taxonomy module.
 * This is the penalty for not having a proper abstraction layer!
 * And for not invoking update hook on terms when changing their parents!
 *
 * @param type $form
 * @param type $form_state
 * @return type 
 */
function taxonomy_edge_reorder_submit($form, &$form_state) {
  $vocabulary = $form['#vocabulary'];
  $hierarchy = 0; // Update the current hierarchy type as we go.

  $changed_terms = array();
  $tree = taxonomy_get_tree($vocabulary->vid);

  if (empty($tree)) {
    return;
  }

  // Build a list of all terms that need to be updated on previous pages.
  $weight = 0;
  $term = (array) $tree[0];
  while ($term['tid'] != $form['#first_tid']) {
    if ($term['parents'][0] == 0 && $term['weight'] != $weight) {
      $term['parent'] = $term['parents'][0];
      $term['weight'] = $weight;
      $changed_terms[$term['tid']] = $term;
    }
    $weight++;
    $hierarchy = $term['parents'][0] != 0 ? 1 : $hierarchy;
    $term = (array) $tree[$weight];
  }

  // Renumber the current page weights and assign any new parents.
  $level_weights = array();
  foreach ($form_state['values'] as $tid => $values) {
    if (isset($form[$tid]['#term'])) {
      $term = $form[$tid]['#term'];
      // Give terms at the root level a weight in sequence with terms on previous pages.
      if ($values['parent'] == 0 && $term['weight'] != $weight) {
        $term['weight'] = $weight;
        $changed_terms[$term['tid']] = $term;
      }
      // Terms not at the root level can safely start from 0 because they're all on this page.
      elseif ($values['parent'] > 0) {
        $level_weights[$values['parent']] = isset($level_weights[$values['parent']]) ? $level_weights[$values['parent']] + 1 : 0;
        if ($level_weights[$values['parent']] != $term['weight']) {
          $term['weight'] = $level_weights[$values['parent']];
          $changed_terms[$term['tid']] = $term;
        }
      }
      // Update any changed parents.
      if ($values['parent'] != $term['parent']) {
        $term['parent'] = $values['parent'];
        $changed_terms[$term['tid']] = $term;
      }
      $hierarchy = $term['parent'] != 0 ? 1 : $hierarchy;
      $weight++;
    }
  }

  // Build a list of all terms that need to be updated on following pages.
  for ($weight; $weight < count($tree); $weight++) {
    $term = (array) $tree[$weight];
    if ($term['parents'][0] == 0 && $term['weight'] != $weight) {
      $term['parent'] = $term['parents'][0];
      $term['weight'] = $weight;
      $changed_terms[$term['tid']] = $term;
    }
    $hierarchy = $term['parents'][0] != 0 ? 1 : $hierarchy;
  }
  // Save all updated terms.
  foreach ($changed_terms as $changed) {
    $term = (object) $changed;
    $term->parent = array($term->parent);
    _taxonomy_edge_taxonomy_term_update($term);
  }
}

// ---------- PRIVATE HELPER FUNCTIONS ----------

/**
 * Insert a term into the edge tree.
 *
 * @param type $term 
 */
function _taxonomy_edge_taxonomy_term_insert($term) {
  $tid = $term->tid;

  // Derive proper parent.
  $parents = _taxonomy_edge_unify_parents($term->parent);

  watchdog('taxonomy_edge', 'Inserting taxonomy-edge for %tid [%parent]', array('%tid' => $tid, '%parent' => join(',', $parents)), WATCHDOG_DEBUG);

  if ($tid > 0) {
    $tx = db_transaction();

    db_insert('taxonomy_term_edge')
      ->fields(array(
        'tid' => $tid,
        'parent' => $tid,
        'distance' => 0,
      ))
      ->execute();
    
    foreach ($parents as $parent) {
      db_query("
        INSERT INTO {taxonomy_term_edge} (tid, parent, distance)
        SELECT DISTINCT :tid, e1.parent, e1.distance + 1
        FROM {taxonomy_term_edge} e1
        LEFT JOIN {taxonomy_term_edge} e2 ON e2.tid = :tid AND e2.parent = e1.parent
        WHERE e1.tid = :parent
        AND e2.tid IS NULL
      ", array(':tid' => $tid, ':parent' => $parent));
    }
  }
  else {
    watchdog('taxonomy_edge', 'Invalid term-id (%tid) received', array('%tid' => $tid), WATCHDOG_ERROR);
  }
}

/**
 * Update a term in the edge tree.
 *
 * @param type $term 
 */
function _taxonomy_edge_taxonomy_term_update($term) {
  $tid = $term->tid;

  if (!isset($term->parent)) {
    // Parent not set, no need to update hierarchy.
    return;
  }

  // Derive proper parent.
  $parents = _taxonomy_edge_unify_parents($term->parent);

  watchdog('taxonomy_edge', 'Updating taxonomy-edge for %tid [%parent]', array('%tid' => $tid, '%parent' => join(',', $parents)), WATCHDOG_DEBUG);

  $tx = db_transaction();

  // Find invalid edges after move
  db_query("CREATE TEMPORARY TABLE {term_edge_delete} (tid INT(11), parent INT(11), PRIMARY KEY (`tid`, `parent`))");
  db_query("
    INSERT INTO {term_edge_delete}
    SELECT DISTINCT te2.tid, te2.parent
    FROM {taxonomy_term_edge} te1
    INNER JOIN {taxonomy_term_edge} te2 ON te1.tid = te2.tid
    WHERE te1.parent = :tid AND te2.distance > te1.distance
  ", array(':tid' => $tid));

  // Delete those edges
  db_query("
    DELETE e.*
    FROM {taxonomy_term_edge} e
    JOIN {term_edge_delete} ed ON e.tid = ed.tid AND e.parent = ed.parent
  ");

  if ($parents) {
    // Insert new and correct edges
    $args = array(
      ':parents' => array_values($parents),
      ':tid' => $tid
    );
    db_query("
      INSERT INTO {taxonomy_term_edge} (tid, parent, distance)
      SELECT DISTINCT te2.tid, te1.parent, te1.distance + te2.distance + 1
      FROM {taxonomy_term_edge} te1
      INNER JOIN {taxonomy_term_edge} te2 ON te1.tid IN (:parents) AND te2.parent = :tid
      LEFT JOIN {taxonomy_term_edge} te3 ON te2.tid = te3.tid AND te1.parent = te3.parent
      WHERE te3.tid IS NULL
    ", $args);
  }

  // Clean up
  db_query("DROP TEMPORARY TABLE {term_edge_delete}");
}

/**
 * Delete a term from the edge tree.
 *
 *  * @param $tid
 *   Term ID.
 */
function _taxonomy_edge_taxonomy_term_delete($term) {
  db_query("DELETE FROM {taxonomy_term_edge} WHERE tid = :tid OR parent = :tid", array('tid' => $term->tid));
}

/**
 * Queue an operation for the edge tree.
 *
 * @param type $term
 * @param type $op
 *   insert, update or delete
 */
function _taxonomy_edge_taxonomy_term_queue($term, $op) {
  // Wait for rebuild to clear queue and initiate snapshot of term_hierarchy
  if (lock_may_be_available('taxonomy_edge_rebuild') || lock_wait('taxonomy_edge_rebuild', 2)) {
    $queue = DrupalQueue::get('taxonomy_edge', TRUE);
    $term->operation = $op;
    $queue->createItem($term);
  }
}

/**
 * Unify parents
 *
 * @param type $parents
 * @return type 
 */
function _taxonomy_edge_unify_parents($parents) {
  $parents = is_array($parents) ? $parents : array($parents);
  $new_parents = array();
  foreach ($parents as $parent) {
    if (is_array($parent)) {
      foreach ($parent as $new) {
        $new_parents[] = $new;
      }
    }
    else {
      $new_parents[] = $parent;
    }
  }
  return $new_parents;
}

// ---------- PUBLIC HELPER FUNCTIONS ----------

/**
 * Process edge for a queued term.
 * @param type $term 
 */
function taxonomy_edge_process_queue_item($term) {
  switch ($term->operation) {
    case 'insert':
      _taxonomy_edge_taxonomy_term_insert($term);
      break;
    case 'update':
      _taxonomy_edge_taxonomy_term_update($term);
      break;
    case 'delete':
      _taxonomy_edge_taxonomy_term_delete($term);
      break;
  }
}

/**
 * Rebuild edges
 */
function taxonomy_edge_cron_rebuild() {
  taxonomy_edge_rebuild_batch();
  $batch = &batch_get();
  $batch['progressive'] = FALSE;
  batch_process('admin/content/taxonomy/edge');
}

/**
 * Start batch job for rebuild of edges
 */
function taxonomy_edge_rebuild_batch() {
  $batch = array(
    'operations' => array(
      array('taxonomy_edge_rebuild', array())
    ),
    'finished' => 'taxonomy_edge_rebuild_finished',
    'file' => drupal_get_path('module', 'taxonomy_edge') . '/taxonomy_edge.pages.inc',
    'title' => t('Rebuilding taxonomy edges'),
    'init_message' => t('Rebuilding taxonomy edges'),
  );
  batch_set($batch);
}

/**
 * Finished function for rebuild tree batch operation.
 *
 * @param type $success
 * @param type $result
 * @param type $operations 
 */
function taxonomy_edge_rebuild_finished($success, $result, $operations) {
  if ($success) {
    drupal_set_message(t('Taxonomy edges rebuilt: %rows processed with depth %depth in %time seconds', 
      array('%rows' => $result['rows'], '%depth' => $result['depth'], '%time' => sprintf("%.03f", $result['time'])))
    );
  }
  else {
    drupal_set_message(t('Taxonomy edges rebuilt: FAILED'), 'error');
  }
}

/**
 * Rebuild entire edge list.
 *
 * @return integer
 *   Total number of rows inserted.
 */
function taxonomy_edge_rebuild(&$context) {
  $depth = 0;
  $max_depth = variable_get('taxonomy_edge_max_depth', TAXONOMY_EDGE_MAX_DEPTH);

  // Acquire lock to avoid conflicts with queue
  if (!lock_acquire('taxonomy_edge_rebuild')) {
    $context['success'] = FALSE;
    $context['message'] = t('Could not acquire lock!');
    return;
  }

  $time = microtime(TRUE);
  set_time_limit(86400);

  // Clear the queue, we're rebulding anyways ...
  $queue = DrupalQueue::get('taxonomy_edge', TRUE);
  $queue->deleteQueue();

  // Please use a proper isolation level, so that transaction provides us with a
  // snapshot
  $tx = db_transaction();
  lock_release('taxonomy_edge_rebuild');
  
  // Use delete, as truncate is not transaction safe on MySQL.
  // @todo Investigate if db_truncate() is transaction safe.
  db_delete('taxonomy_term_edge')->execute();

  $total_rows = db_query("
    INSERT INTO {taxonomy_term_edge} (tid, parent, distance)
    SELECT DISTINCT h.tid, h.tid, 0
    FROM {taxonomy_term_hierarchy} h
    LEFT JOIN {taxonomy_term_edge} e ON e.tid = h.tid AND e.parent = h.tid
    WHERE h.tid <> 0
    AND h.tid <> h.parent
    AND e.tid IS NULL
  ")->rowCount();
  $context['message'] = t('Processed %rows rows - current depth: %depth', array('%rows' => $total_rows, '%depth' => $depth));
  $context['finished'] = 0.5;
  
  while ($max_depth-- > 0) {
    $result = db_query("
      INSERT INTO {taxonomy_term_edge} (tid, parent, distance)
      SELECT DISTINCT h.tid, e.parent, :depth + 1
      FROM {taxonomy_term_hierarchy} h
      INNER JOIN {taxonomy_term_edge} e ON e.tid = h.parent
      LEFT JOIN {taxonomy_term_edge} e2 ON e2.tid = h.tid AND e2.parent = e.parent
      WHERE e.distance = :depth
      AND h.tid <> 0
      AND h.tid <> h.parent
      AND e2.tid IS NULL
    ", array('depth' => $depth));

    if (!$result) {
      break;
    }

    $rows = $result->rowCount();
    if ($rows <= 0) {
      break;
    }
    $depth++;

    $total_rows += $rows;
    $context['message'] = t('Processed %rows rows - current depth: %depth', array('%rows' => $total_rows, '%depth' => $depth));
    $context['finished'] += (1 - $context['finished']) / 2;
  }
  $context['finished'] = 1;
  $context['results'] = array('rows' => $total_rows, 'depth' => $depth, 'time' => microtime(TRUE) - $time);
  
  return $total_rows;
}

/**
 * Get parent from edge list.
 *
 * @param $tid
 *   term id to get parent from.
 * @return array
 *   array of term ids.
 */
function taxonomy_edge_get_parents($tid) {
  $parents = array();
  $result = db_query("
    SELECT e.parent AS tid, d.name
    FROM {taxonomy_term_edge} e JOIN {taxonomy_term_data} d ON e.parent = d.tid
    WHERE e.tid = :tid
    AND e.distance > 0
    ORDER BY e.distance
  ", array($tid));
  while ($parent = $result->fetchObject()) {
    $parents[] = $parent;
  }
  return $parents;
}

/**
 * Get top term id.
 *
 * @param $tid
 *   Term ID to get top term ID from.
 * @return integer
 *   Top term ID.
 */
function taxonomy_edge_get_top_tid($tid) {
  return db_result(db_query("
    SELECT h.tid
    FROM {taxonomy_term_edge} te
    INNER JOIN {taxonomy_term_hierarchy} h ON te.parent = h.tid
    WHERE h.parent = 0
    AND te.tid = :tid
  ", array(':tid' => $tid)));
}

/**
 * Checks if it's possible to build an edge realtime.
 *
 * @return boolean
 *   TRUE if possible, FALSE if not.
 */
function taxonomy_edge_build_realtime() {
  $queue = DrupalQueue::get('taxonomy_edge', TRUE);
  if ($queue->numberOfItems()) {
    // Don't build realtime, if there are still items left in the queue.
    return FALSE;
  }
  if (!lock_may_be_available('taxonomy_edge_rebuild')) {
    // Don't build realtime, if entire tree rebuild is in progress.
    return FALSE;
  }
  return variable_get('taxonomy_edge_build_realtime', TAXONOMY_EDGE_BUILD_REALTIME);
}

/**
 * Reimplementation of taxonomy_get_tree().
 * Limit db fetch to only specified parent.
 * @see taxonomy_get_tree()
 */
function taxonomy_edge_get_tree($vid, $parent = 0, $max_depth = NULL, $load_entities = FALSE) {
  // @todo Use regular taxonomy_get_tree if realtime build is disabled, 
  //       as this function might be unreliable.
  
  $children = &drupal_static('taxonomy_get_tree', array());
  $parents = &drupal_static('taxonomy_get_tree' . ':parents', array());
  $terms = &drupal_static('taxonomy_get_tree' . ':terms', array());

  // We cache trees, so it's not CPU-intensive to call get_tree() on a term
  // and its children, too.
  if (!isset($children[$vid][$parent])) {
    $children[$vid][$parent] = array();

    $query = db_select('taxonomy_term_data', 't');
    $query->join('taxonomy_term_hierarchy', 'h', 'h.tid = t.tid');
    $query
      ->addTag('translatable')
      ->addTag('term_access')
      ->fields('t')
      ->fields('h', array('parent'))
      ->condition('t.vid', $vid)
      ->orderBy('t.weight')
      ->orderBy('t.name');

    if ($parent) {
      $query->join('taxonomy_term_edge', 'e', 'e.tid = t.tid');
      $query->condition('e.parent', $parent);
    }

    $result = $query->execute();

    foreach ($result as $term) {
      // @todo Optimize this. Using tids as index protects us from multiple
      //       calls at the expense of performance on large trees.
      $children[$vid][$term->parent][$term->tid] = $term->tid;
      $parents[$vid][$term->tid][$term->parent] = $term->parent;
      $terms[$vid][$term->tid] = $term;
    }
  }

  // Load full entities, if necessary. The entity controller statically
  // caches the results.
  if ($load_entities) {
    $term_entities = taxonomy_term_load_multiple(array_keys($terms[$vid]));
  }

  $max_depth = (!isset($max_depth)) ? count($children[$vid]) : $max_depth;
  $tree = array();

  // Keeps track of the parents we have to process, the last entry is used
  // for the next processing step.
  $process_parents = array();
  $process_parents[] = $parent;

  // Loops over the parent terms and adds its children to the tree array.
  // Uses a loop instead of a recursion, because it's more efficient.
  while (count($process_parents)) {
    $parent = array_pop($process_parents);
    // The number of parents determines the current depth.
    $depth = count($process_parents);
    if ($max_depth > $depth && !empty($children[$vid][$parent])) {
      $has_children = FALSE;
      $child = current($children[$vid][$parent]);
      do {
        if (empty($child)) {
          break;
        }
        $term = $load_entities ? $term_entities[$child] : $terms[$vid][$child];
        if (count($parents[$vid][$term->tid]) > 1) {
          // We have a term with multi parents here. Clone the term,
          // so that the depth attribute remains correct.
          $term = clone $term;
        }
        $term->depth = $depth;
        unset($term->parent);
        $term->parents = array_values($parents[$vid][$term->tid]);
        $tree[] = $term;
        if (!empty($children[$vid][$term->tid])) {
          $has_children = TRUE;

          // We have to continue with this parent later.
          $process_parents[] = $parent;
          // Use the current term as parent for the next iteration.
          $process_parents[] = $term->tid;

          // Reset pointers for child lists because we step in there more often
          // with multi parents.
          reset($children[$vid][$term->tid]);
          // Move pointer so that we get the correct term the next time.
          next($children[$vid][$parent]);
          break;
        }
      } while ($child = next($children[$vid][$parent]));

      if (!$has_children) {
        // We processed all terms in this hierarchy-level, reset pointer
        // so that this function works the next time it gets called.
        reset($children[$vid][$parent]);
      }
    }
  }

  return $tree;
}
